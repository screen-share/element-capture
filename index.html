<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>Element Capture</title>
    <script class="remove" src="element-capture.js" type="text/javascript"></script>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  </head>
  <body>
    <section id="abstract">
      <h2>Abstract</h2>
      <p>
        Pre-existing mechanisms such as {{MediaDevices/getDisplayMedia()}} allow Web applications to
        initiate screen-capture. If the user chooses to share a tab, the capturing application has a
        video {{MediaStreamTrack}}. Mechanisms such as [[mediacapture-region|Region Capture]] allow
        this track to be mutated - performing some operation on the captured frames. (In the case of
        [[mediacapture-region|Region Capture]], this mutation consists of cropping.)
      </p>
      <p>
        This document introduces a new mutation mechanism which we name "restriction". After a Web
        application "restricts" a video track to a given target-element, frames produced on that
        video track only consist information from the target-element and (and its descendants).
        Phrased differently, the track becomes a capture of the DOM sub-tree rooted at the
        target-element.
      </p>
    </section>
    <section id="sotd"></section>
    <section id="conformance"></section>
    <section id="use-cases">
      <h2>Use Cases</h2>
      <section id="generic-use-case">
        <h3>Generic Use-Case</h3>
        <p>
          [[mediacapture-region|Region Capture]] allows applications to crop captures. Assume some
          element <code>TARGET</code> is the crop-target. What if other elements, which are not
          DOM-descendants of <code>TARGET</code>, draw in front of <code>TARGET</code>? Using
          [[mediacapture-region|Region Capture]], these other elements would also get captured,
          which is not always desirable. A mechanism is sought that would allow cropping to
          <code>TARGET</code>'s bounding box, while also excluding from capture any of the content
          that is not a DOM-descendant.
        </p>
      </section>
      <section id="practical-use-case-1">
        <h3>Practical Use-Case #1: Recording part of an app</h3>
        <p>
          Consider an "editor" Web application (text-editor, image-editor, slides-editor or
          video-editor). Such applications often include a main content area, surrounded by various
          toolbars, drop-down menus and widgets which allow the local user to edit the content in
          the main content area.
        </p>
        <p>
          Sometimes a Web application wishes to record only the main content area, and then either
          transmit it "live" to remote participants, or record it to disk. Such an application would
          not necessarily wish to expend storage, bandwidth, or remote participants' screen
          real-estate on anything outside of the main content area.
        </p>
        <p>
          A mechanism such as [[mediacapture-region|Region Capture]] helps with cropping to the
          bounding box of the target-element, but what happens when drop-down lists temporarily draw
          over it?
        </p>
      </section>
      <section id="practical-use-case-2">
        <h3>Practical Use-Case #2: Collaborative tools during video-conferencing</h3>
        <p>
          Video-conferencing applications often arrange themselves using "tiles" - each remote
          participant's video is presented in a tile. Assume that a collaborative Web application,
          like a text editor or an image-editing application, is loaded in another iframe, and that
          this iframe is also presented as a tile.
        </p>
        <p>
          Some remote participants would similarly load the same tool in a dedicated tile. But what
          if some users don't have the necessary permissions to load that tool? Or if they are
          joining from a platform that does not support the tool?
        </p>
        <p>
          The video conferencing solution may then choose to have one of the participants who have
          loaded the tool successfully screen-share that tool's tile to the users who cannot load
          the tool, allowing them to at least view it, although not interact with it. This can be
          done using self-capture through {{MediaDevices/getDisplayMedia()}} and
          [[mediacapture-region|Region Capture]].
        </p>
        <p>
          But such a solution introduces some problems. What happens if other elements ever draw on
          top of the tool tile, either briefly or permanently? Examples include:
        </p>
        <ul>
          <li>Private messages sent inside of the video-conferencing application.</li>
          <li>Requests by new users to join.</li>
          <li>Other tiles during tile-layout changes.</li>
          <li>Drop-down lists from other elements of the video-conferencing application.</li>
        </ul>
      </section>
    </section>
    <section id="solution-overview">
      <h2>Solution Overview</h2>
      <p>The Element Capture mechanism comprises two parts:</p>
      <ol>
        <li>
          [=CropTarget production=]: A mechanism for <dfn>tagging</dfn> an {{Element}} as a
          potential target for the [=restriction mechanism=].
        </li>
        <li>
          [=Restriction mechanism=]: A mechanism for instructing the user agent to start restricting
          a video track to the bounding box of a previously [=tagging|tagged=] {{Element}}, or to
          stop such restriction and revert a track to its [=unrestricted=] state.
        </li>
      </ol>
      <p>
        We define two <dfn>restriction-states</dfn>. <dfn>restricted</dfn> and
        <dfn>unrestricted</dfn>. Video tracks are always in one state or the other. Tracks start out
        [=unrestricted=], and may turn to [=restricted=] when
        {{BrowserCaptureMediaStreamTrack/restrictTo()}} is successfully called.
      </p>
    </section>
    <section id="produce-crop-target">
      <h2><dfn>CropTarget Production</dfn></h2>
      <p>
        The [[mediacapture-region|Region Capture]] specification details before the
        <a data-cite="mediacapture-region#produce-crop-target">mechanism</a> for {{CropTarget}}s as
        well as the <a data-cite="mediacapture-region#crop-target-motivation">motivation</a> for
        using them.
      </p>
    </section>
    <section id="restricting-a-track">
      <h2><dfn>Restriction Mechanism</dfn></h2>
      <section>
        <h3>Definitions</h3>
        <section>
          <h4>Restrictable tracks</h4>
          <p>
            We say that a {{MediaStreamTrack}} <var>T</var> is a
            <dfn>restrictable MediaStreamTrack</dfn> if and only if it fulfills all of the following
            conditions:
          </p>
          <ul>
            <li>
              <var>T</var> is either a {{MediaStreamTrack}} returned inside of a {{MediaStream}}
              through a call to {{MediaDevices/getDisplayMedia()}}, or a clone of such a track.
            </li>
            <li>
              <var>T</var>.<a data-cite="mediacapture-streams/#dfn-kind">kind</a> is
              <a data-cite="mediacapture-streams/#dfn-video">"video"</a>.
            </li>
            <li>
              <var>T</var>.<a data-cite="mediacapture-streams/#dfn-readystate">readyState</a> is
              <a data-cite="mediacapture-streams/#idl-def-MediaStreamTrackState.live">"live"</a>.
            </li>
            <li><var>T</var> is not <a data-cite="mediacapture-region#dfn-cropped">cropped</a>.</li>
          </ul>
        </section>
        <section>
          <h4>Elements eligible for restriction</h4>
          <p>
            We say that an {{Element}} <var>E</var> is <dfn>eligible for restriction</dfn> if and
            only if it fulfils all of the following conditions:
          </p>
          <ul>
            <li>
              <p><var>E</var> forms a stacking context.</p>
            </li>
            <li>
              <p>
                <var>E</var> is
                <a data-cite="css-transforms-2#grouping-property-values">flattened in 3D.</a>
              </p>
            </li>
            <li>
              <p>
                <var>E</var> forms a
                <a data-cite="filter-effects-2/#backdrop-root">backdrop root</a>.
              </p>
            </li>
            <li>
              <p>
                <var>E</var> has exactly one
                <a data-cite="css-break-4/#box-fragment">box fragment</a>.
              </p>
            </li>
            <li>
              <p><var>E</var> is <a data-cite="css-images-4/#element-not-rendered">rendered</a>.</p>
            </li>
          </ul>
          <div class="note">
            <p>
              To ensure these conditions hold, developers may use CSS such as the following snippet:
            </p>
            <pre class="css">
              #target {
                isolation: isolate;     /* Forms a stacking context. */
                transform-style: flat;  /* Flattened. */
              }
            </pre>
          </div>
        </section>
        <h4>Valid restriction targets</h4>
        <p>
          We say that an {{Element}} <var>E</var> is a <dfn>valid restriction target</dfn> for a
          {{MediaStreamTrack}} <var>T</var>, if and only if all of the following conditions hold:
        </p>
        <ul>
          <li><var>T</var> is a [=restrictable MediaStreamTrack=].</li>
          <li><var>E</var> is a [=eligible for restriction=].</li>
          <li>
            The [=top-level browsing context=] of the
            <a data-cite="screen-capture/#dfn-display-surface">display surface</a>
            that is the source of <var>T</var>, is <var>E</var>'s [=shadow-including root=].
          </li>
        </ul>
        <div class="note">
          <p>
            Informally, this means that <var>T</var> is an active video track associated with
            tab-capture, and <var>E</var> is an Element [=connected=] to the DOM in the captured
            tab.
          </p>
          <p>
            Note that whether an Element <var>E</var> is a [=valid restriction target=] for a
            {{MediaStreamTrack}} <var>T</var> may change either before or after a capture starts, as
            well as before or after restriction starts. Examples include:
          </p>
          <ul>
            <li><var>T</var> is stopped programmatically.</li>
            <li><var>T</var> is stopped by the user.</li>
            <li>
              <var>T</var>.<a data-cite="mediacapture-streams/#dfn-source-0">[[\Source]]</a> changes
              due to user interaction with the user agent and/or operating system.
            </li>
            <li><var>E</var>'s set of CSS attributes changes.</li>
          </ul>
          <p>Invalidity before restriction starts will suppress restriction.</p>
          <p>
            Invalidity after restriction starts will suppress additional frames until validity is
            restored.
          </p>
        </div>
      </section>
      <section id="browser-capture-media-stream-track-extension">
        <h3>BrowserCaptureMediaStreamTrack extension</h3>
        <p>
          [[mediacapture-region|Region Capture]] introduced the {{BrowserCaptureMediaStreamTrack}}
          interface. We extend it with a new method, {{BrowserCaptureMediaStreamTrack/restrictTo}}.
        </p>
        <pre class="idl">
          [Exposed = Window]
          partial interface BrowserCaptureMediaStreamTrack {
            Promise&lt;undefined&gt; restrictTo(CropTarget? cropTarget);
          };
        </pre>
        <dl
          data-link-for="BrowserCaptureMediaStreamTrack"
          data-dfn-for="BrowserCaptureMediaStreamTrack"
        >
          <dt>
            <dfn>restrictTo()</dfn>
          </dt>
          <dd>
            <p>
              Calls to this method instruct the user agent to start/stop restrict a video track.
            </p>
            <p>
              When invoked with <var>cropTarget</var> as the first parameter, the user agent MUST
              execute the following algorithm:
            </p>
            <ol>
              <li>
                <p>
                  If [=this=] is not a [=restrictable MediaStreamTrack=], return a {{Promise}}
                  [=rejected=] with a new {{NotSupportedError}}.
                </p>
              </li>
              <li>Let <var>p</var> be a new {{Promise}}.</li>
              <li>
                <p>Run the following steps in parallel:</p>
                <ol>
                  <li>
                    <p>Let <var>E</var> be <var>cropTarget</var>.{{CropTarget/[[Element]]}}.</p>
                  </li>
                  <li>
                    <p>
                      If <var>E</var> is not a [=valid restriction target=] for [=this=], return a
                      {{Promise}} [=rejected=] with a new {{InvalidStateError}}.
                    </p>
                  </li>
                  <li>
                    <p>
                      Update [=this=] video track's [=restriction-state=] according to
                      <var>cropTarget</var>:
                    </p>
                    <ol>
                      <li>
                        If <var>cropTarget</var> is NOT {{undefined}}, the user agent MUST set
                        [=this=] video track's [=restriction-state=] to [=restricted=] and start
                        [=applying the restriction transformation=] to all frames delivered to
                        [=this=] video track with <var>cropTarget</var> as the target.
                      </li>
                      <li>
                        If <var>cropTarget</var> is set to {{undefined}}, the user agent MUST set
                        [=this=] video track's [=restriction-state=] to [=unrestricted=] and stop
                        [=applying the restriction transformation=] to frames delivered to [=this=]
                        video track.
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>
                      Call the track's state before this method invocation <var>PRE-STATE</var>, and
                      after this method invocation <var>POST-STATE</var>. The user agent MUST
                      resolve <var>p</var> when it is guaranteed that no more frames [=restricted=]
                      (or [=unrestricted=]) according to <var>PRE-STATE</var> will be delivered to
                      the application, and that any additional frames delivered to the application
                      will therefore be [=restricted=] (or [=unrestricted=]) according to either
                      <var>POST-STATE</var> or a later state.
                    </p>
                  </li>
                </ol>
              </li>
              <li>Return <var>p</var>.</li>
            </ol>
          </dd>
        </dl>
      </section>
    </section>
    <section id="applying-the-restriction-transformation">
      <h2><dfn>Applying the restriction transformation</dfn></h2>
      <p>
        Whenever the user agent is about to produce a new <var>frame</var> for a video track
        <var>T</var> that is [=restricted=] to a given target <var>cropTarget</var>, the user agent
        MUST execute the following algorithm:
      </p>
      <ol>
        <li>Let <var>E</var> be <var>cropTarget</var>.{{CropTarget/[[Element]]}}.</li>
        <li>
          If <var>E</var> is not a [=valid restriction target=] for <var>T</var>, abort without
          producing a new frame.
        </li>
        <li>
          Let <var>intersection</var> be the intersection of <var>E</var>'s bounding box and the
          captured surface's [=top-level browsing context=]'s viewport.
        </li>
        <li>If <var>intersection</var> is empty, abort without producing a new frame.</li>
        <li>
          A corollary of previous steps is that <var>E</var> forms a stacking context. Produce and
          deliver a frame consisting of an independent rendering of that stacking context, clipped
          to <var>intersection</var>.
        </li>
      </ol>
    </section>
    <section id="sample-code">
      <h2>Sample Code</h2>
      <div class="example">
        <p>Code in the capture-target:</p>
        <pre class="javascript">
          const mainContentArea = navigator.getElementById('mainContentArea');
          const cropTarget = await CropTarget.fromElement(mainContentArea);
          sendCropTarget(cropTarget);

          function sendCropTarget(cropTarget) {
            // Either send the crop-target using postMessage(),
            // or pass it on locally within the same document.
          }
        </pre>
      </div>
      <div class="example">
        <p>Code in the capturing-document:</p>
        <pre class="javascript">
          async function startRestrictedCapture(cropTarget) {
            const stream = await navigator.mediaDevices.getDisplayMedia();
            const [track] = stream.getVideoTracks();
            if (!!track.restrictTo) {
              handleError(stream);
              return;
            }
            await track.restrictTo(cropTarget);
            transmitVideoRemotely(track);
          }
        </pre>
      </div>
    </section>
  </body>
</html>
